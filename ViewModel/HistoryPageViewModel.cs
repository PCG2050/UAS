using CommunityToolkit.Mvvm.ComponentModel; // For ObservableObject and [ObservableProperty]
using CommunityToolkit.Mvvm.Input;       // For RelayCommand and AsyncRelayCommand
using System.Collections.ObjectModel;   // For ObservableCollection
using UAS.Data;                         // For HistoryItem data model
using UAS.Views;                        // For navigation to HistoryPage
using System;                           // For DateTime
using System.Linq;                      // For LINQ operations

namespace UAS.ViewModel
{
    // HistoryPageViewModel manages the data and logic for the HistoryPage.
    // It inherits from ObservableObject to enable data binding notifications.
    public partial class HistoryPageViewModel : ObservableObject
    {
        // ObservableCollection to hold the list of history items that are currently displayed (filtered).
        [ObservableProperty]
        private ObservableCollection<HistoryItem> _historyItems;

        // Private list to hold all history items before filtering. This is the master list.
        private List<HistoryItem> _allHistoryItems;

        // Property to bind the selected date from the DatePicker. Nullable to allow no date selected.
        // The [ObservableProperty] attribute automatically generates SelectedFilterDate property
        // and the partial method OnSelectedFilterDateChanged.
        [ObservableProperty]
        private DateTime? _selectedFilterDate;

        // Static properties for DatePicker min/max dates.
        // These define the selectable range for the DatePicker UI.
        // They are static so they can be accessed directly from XAML using x:Static.
        public static DateTime MinFilterDate => new DateTime(2025, 1, 1);
        public static DateTime MaxFilterDate => new DateTime(2025, 12, 31);


        public HistoryPageViewModel()
        {
            _allHistoryItems = new List<HistoryItem>(); // Initialize the master list
            _historyItems = new ObservableCollection<HistoryItem>(); // Initialize the collection that the UI binds to
            LoadDummyData(); // Load some initial dummy data into the master list

            // Initialize the backing field for SelectedFilterDate to null.
            // This ensures the DatePicker initially shows its placeholder text ("Select a date to filter").
            // Setting this value will automatically trigger the OnSelectedFilterDateChanged
            // partial method (due to [ObservableProperty]), which in turn calls ApplyFilter().
            // This ensures all items are displayed by default when the page loads.
            _selectedFilterDate = null;
        }

        // Command executed when the "Edit" button on a table row is clicked.
        // [RelayCommand] automatically generates the public ICommand `EditHistoryItemCommand`.
        [RelayCommand]
        private async Task EditHistoryItem(HistoryItem itemToEdit)
        {
            if (itemToEdit == null)
                return; // Safety check: if no item is passed, do nothing.

            // Navigate to the EditHistoryItemPage.
            // We pass the 'Id' of the selected item as a query parameter.
            // The query parameter name "itemId" must precisely match the [QueryProperty] attribute
            // in the `EditHistoryItemViewModel` of the `EditHistoryItemPage`.
            await Shell.Current.GoToAsync($"{nameof(EditHistoryItemPage)}?itemId={itemToEdit.Id}");
        }

        // This partial method is automatically generated by the [ObservableProperty] attribute
        // associated with the `_selectedFilterDate` backing field.
        // It is called every time the `SelectedFilterDate` property's value changes (e.g., when the user picks a date
        // from the DatePicker, or when the "Clear" button is pressed).
        partial void OnSelectedFilterDateChanged(DateTime? value)
        {
            // When the filter date changes, re-apply the filter to update the displayed list.
            ApplyFilter();
        }

        // Command to clear the currently selected date filter.
        // [RelayCommand] automatically generates the public ICommand `ClearDateFilterCommand`.
        [RelayCommand]
        private void ClearDateFilter()
        {
            // Setting `SelectedFilterDate` to `null` will trigger `OnSelectedFilterDateChanged`,
            // which then calls `ApplyFilter()`, effectively removing the date filter and showing all items.
            SelectedFilterDate = null;
        }

        // Method responsible for filtering the `_allHistoryItems` and populating `_historyItems`.
        private void ApplyFilter()
        {
            _historyItems.Clear(); // Clear the currently displayed items in the CollectionView.

            if (SelectedFilterDate == null)
            {
                // If no filter date is selected (i.e., `SelectedFilterDate` is null),
                // display all items from the master list.
                foreach (var item in _allHistoryItems)
                {
                    _historyItems.Add(item);
                }
            }
            else
            {
                // If a filter date is selected, filter items based on that date.
                // We use `.Date` to compare only the date part, ignoring any time components.
                var filterDate = SelectedFilterDate.Value.Date; // Get only the date part from the nullable DateTime.

                // Iterate through the master list and add only the items that match the filter date.
                foreach (var item in _allHistoryItems.Where(i => i.Date.Date == filterDate))
                {
                    _historyItems.Add(item);
                }
            }
        }

        // Method to load dummy data into the `_allHistoryItems` (master list).
        // This data simulates what would typically come from a database or API.
        private void LoadDummyData()
        {
            for (int i = 1; i <= 20; i++) // Create 20 dummy history items for demonstration.
            {
                _allHistoryItems.Add(new HistoryItem
                {
                    Id = $"item{i}", // Unique ID for each item, useful for navigation and identity.
                    // Dates are set to repeat across June 1st to 5th, 2025.
                    // This allows for easy testing of the date filtering (e.g., pick June 3rd to see specific items).
                    Date = new DateTime(2025, 6, (i % 5) + 1),
                    Time = $"{(8 + i % 12):D2}:00 {(i % 2 == 0 ? "AM" : "PM")}", // Alternating AM/PM for variety.
                    EventName = $"Event {i}",
                    Location = $"Location {i % 5 + 1}", // Locations 1-5 for variety.
                    Status = (i % 3 == 0) ? "Completed" : (i % 3 == 1 ? "Pending" : "In Progress"), // Varied statuses.
                    Notes = $"This is a dummy note for event {i}. It provides a brief description.",
                    Category = (i % 2 == 0) ? "Work" : "Personal",
                    Priority = (i % 4 == 0) ? "High" : (i % 4 == 1 ? "Medium" : "Low") // Varied priorities.
                });
            }
        }
    }
}